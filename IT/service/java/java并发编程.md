## 《Java并发编程实战-王宝令》学习笔记

### 开篇词 | 你为什么需要学习并发编程？

```
　　信号量模型—>管道模型；
　　Doug Lea是真大神,java1.5并发包作者,也是hashmap作者之一
　　并发编程可以总结为三个核心问题：分工、同步、互斥：

　　分工指的是如何高效地拆解任务并分配给线程；Fork/Join 框架；

　　同步指的是线程之间如何协作，一个线程执行完了一个任务，如何通知执行后续任务的线程开工； Executor、Fork/Join、Future 、CountDownLatch、CyclicBarrier、Phaser、Exchanger；

　　互斥则是保证同一时刻只允许一个线程访问共享资源；可重入锁．

推荐书籍：《计算机的心智-操作系统之哲学原理》

		  《操作系统精髓与设计原理》

		  《unix操作系统设计》

		  《linux 0.11的源代码》

　　　　　《Java并发编程实战》《Java并发编程的艺术》《图解Java多线程设计模式》《操作系统：精髓与设计原理》

相关网站：http://ifeve.com＼

　　　　　http://www.cs.umd.edu/~pugh/java/memoryModel/ 
```

### 学习攻略 | 如何才能学好并发编程？

![1577756285937](java并发编程.assets/1577756285937.png)

```
一、“跳出来，看全景”
１．建立起一张全景图。
　　并发编程领域可以抽象成三个核心问题：分工、同步和互斥：　
２．最佳的方式就是和现实世界做对比
二、“钻进去，看本质”
１．工程上的解决方案，一定要有理论做基础，技术的本质是背后的理论模型。
```



### 01 可见性、原子性和有序性问题：并发编程Bug的源头

```
１．Bug 的源头：CPU、内存、I/O 设备这三者的速度差异；
２．缓存（可见性问题）、线程切换（原子性问题）、编译优化（有序性问题）
３．技术在解决一个问题的同时，必然会带来另外一个问题，所以在采用一项技术的同时，一定要清楚它带来的问题是什么，以及如何规避。
```



### 02  Java内存模型：看Java如何解决可见性和有序性问题

```
一．Java 内存模型。
	站在我们这些程序员的视角，本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法：
	volatile、synchronized 和 final 三个关键字，以及六项Happens-Before 规则，
	volatile：告诉编译器，对这个变量的读写，不能使用 CPU 缓存，必须从内存中读取或者写入．
	Happens-Before 规则：前面一个操作的结果对后续操作是可见的。Happens-Before 约束了编译器的优化行为，虽允许编译器优化，但是要求编译器优化后一定遵守 Happens-Before 规则：
	１．程序的顺序性规则：这条规则是指在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。
	２．volatile 变量规则：这条规则是指对一个volatile变量的写操作，Happens-Before于后续对这个volatile变量的读操作。
	３．传递性：这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。
	４．管程中锁的规则：这条规则是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。（。管程是一种通用的同步原语，在Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现。管程中的锁在 Java 里是隐式实现的）
	５．线程 start() 规则：这条是关于线程启动的。它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。
	６．线程 join() 规则：如果在线程 A 中，调用线程 B 的 join() 并成功返回，那么线程 B 中的任意操作 Happens-Before 于该 join() 操作的返回。
	
	final关键字：初衷是告诉编译器：这个变量生而不变，可以可劲儿优化。
```

相关参考：

1. [JSR 133 (Java Memory Model) FAQ](http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html)
2. [Java 内存模型 FAQ](http://ifeve.com/jmm-faq/) （）
3. [JSR-133: JavaTM Memory Model and Thread Specification](https://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf)

### 03 互斥锁（上）：解决原子性问题

```
一.原子性问题到底该如何解决
	1.一个或者多个操作在 CPU 执行的过程中不被中断的特性，称为“原子性”，原子性问题的源头是线程切换。“同一时刻只有一个线程执行”这个条件非常重要，我们称之为互斥。
	2.锁：
	简易锁模型：加锁操作:lock()->临界区：一段代码->解锁操作：unlock()
	改进后的锁模型：把临界区要保护的资源标 R 注出来->加锁操作:lock()->临界区：资源R->解锁操作：unlock()
	3.Java 语言提供的锁技术：synchronized
```

### 04 互斥锁（下）：如何用一把锁保护多个资源？

```
一、受保护资源和锁之间合理的关联关系应该是 N:1 的关系，首先要区分这些资源是否存在关联关系。
　　对如何保护多个源：关键是要分析多个资源之间的关系。
　　如果资源之间没有关系，很好处理，每个资源一把锁就可以了。
　　如果资源之间有关联关系，就要选择一个粒度更大的锁，这个锁应该能够覆盖所有相关的资源。
　　除此之外，还要梳理出有哪些访问路径，所有的访问路径都要设置合适的锁，这个过程可以类比一下门票管理。
　　
　　“原子性”的本质是：其实不是不可分割，解决原子性问题，是要保证中间状态对外不可见。
　　细粒度锁：用不同的锁对受保护资源进行精细化管理，能够提升性能。这种锁还有个名字。
　　
　　例子：
	1.保护没有关联关系的多个资源（一个锁保护一个资源）
	银行业务:
　　　　账户类 Account
　　　　　　账户余额balance():取款 withdraw();查看余额 getBalance()
　　　　　　锁: final balLock 
　　　　账户密码 password()
　　　　　　更改密码 updatePassword() 
　　　　　　查看密码 getPassword()
　　　　　　锁： final pwLock
	可以用一把互斥锁来保护多个资源：性能太差
	2.保护有关联关系的多个资源（锁能覆盖所有受保护资源）
	银行业务:
	　　账户类 Account
	　　转账操作：账户余额balance():取款 withdraw();查看余额 getBalance()；转账操作 transfer()
	　　Account.class 作为共享的锁
```

### 05 一不小心就死锁了，怎么办？

```
一、使用细粒度锁可以提高并行度，是性能优化的一个重要手段，识别出风险很重要。
　　账本：转出账本和转入账本
　　例子：Account.class　改为细粒度锁：
　　　　锁定转出账户synchronized(this)；锁定转入账户synchronized(target)
二、使用细粒度锁可能需要复出代价：死锁
　　死锁的一个比较专业的定义是：一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象。
　　如何预防死锁：规避死锁
　　死锁的四个条件（coffman）：
　　1. 互斥，共享资源 X 和 Y 只能被一个线程占用；
　　2. 占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
　　3. 不可抢占，其他线程不能强行抢占线程 T1 占有的资源；
　　4. 循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。
　　反过来分析，也就是说只要我们破坏其中一个，就可以成功避免死锁的发生：
　　１．互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥．
　　２. 对于“占用且等待”这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。Allocator。
　　３. 对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。
　　４. 对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。
　　
　　例子：
　　Allocator：“同时申请”这个操作是一个临界区，同时申请资源 apply() 和同时释放资源 free()。
```

### 06 用“等待-通知”机制优化循环等待

```
一、等待 - 通知机制：
	用 synchronized 实现等待 - 通知机制：wait()、notify()、notifyAll()
	四要素：1. 互斥锁；2. 线程要求的条件：3. 何时等待：4. 何时通知：
	尽量使用 notifyAll()：notify() 是会随机地通知等待队列中的一个线程，而 notifyAll() 会通知等
待队列中的所有线程。
	
    例：完美的就医流程：
        1. 患者先去挂号，然后到就诊门口分诊，等待叫号；
        2. 当叫到自己的号时，患者就可以找大夫就诊了；
        3. 就诊过程中，大夫可能会让患者去做检查，同时叫下一位患者；
        4. 当患者做完检查后，拿检测报告重新分诊，等待叫号；
        5. 当大夫再次叫到自己的号时，患者再去找大夫就诊。
```

### 07 安全性、活跃性以及性能问题（总结前6章）

```
一、安全性问题
　　什么是线程安全：程序按照我们的期望执行；
　　线程安全要避免：原子性问题、可见性问题和有序性问题。
　　需要分析线性安全的问题：存在共享数据并且该数据会发生变化，通俗地讲就是有多个线程会同时读写同一数据。
　　	数据竞争（DataRace）：当多个线程同时访问同一数据，并且至少有一个线程会写这个数据的时候；
　　　竞态条件（Race Condition）：所谓竞态条件，指的是程序的执行结果依赖线程执行的顺序。
　　解决技术方案：互斥：锁。
二、活跃性问题
　　什么是活跃性问题：指的是某个操作无法执行下去。
　　死锁：阻塞（设计合适的锁）；
　　活锁：有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况：同向让路问题（随机等待时间）；
　　饥饿：线程因无法访问所需资源而无法执行下去的情况（一是保证资源充足，二是公平地分配资源（公平锁），三就是避免持有锁的线程长时间执行）。
三、性能问题
	尽量减少串行，
	阿姆达尔（Amdahl）定律：S = 1／（(1−p)+ｐ／ｎ）　【n 可以理解为 CPU 的核数，p 可以理解为并行百分比，】
```

